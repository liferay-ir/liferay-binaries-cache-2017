'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.runPlugins = runPlugins;
exports.runBabel = runBabel;

var _babelCore = require('babel-core');

var babel = _interopRequireWildcard(_babelCore);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _babelIpc = require('liferay-npm-build-tools-common/lib/babel-ipc');

var babelIpc = _interopRequireWildcard(_babelIpc);

var _globs = require('liferay-npm-build-tools-common/lib/globs');

var gl = _interopRequireWildcard(_globs);

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _config = require('./config');

var config = _interopRequireWildcard(_config);

var _log = require('./log');

var log = _interopRequireWildcard(_log);

var _report = require('./report');

var _report2 = _interopRequireDefault(_report);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Run a liferay-npm-bundler plugin
 * @param  {Array} plugins list of plugin descriptors (with name, config and run fields)
 * @param  {PkgDesc} srcPkg source package descriptor
 * @param  {PkgDesc} pkg processed package descriptor
 * @param  {Object} state state to pass to plugins
 * @param  {function} callback a callback function to invoke once per plugin with the used plugin and PluginLogger
 * @return {Object} the state object
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function runPlugins(plugins, srcPkg, pkg, state, callback) {
	plugins.forEach(function (plugin) {
		var params = {
			config: plugin.config,
			log: new _pluginLogger2.default(),
			rootPkgJson: (0, _readJsonSync2.default)('package.json'),
			globalConfig: config.getGlobalConfig(),

			pkg: pkg.clone(),

			source: {
				pkg: srcPkg.clone()
			}
		};

		plugin.run(params, state);

		if (callback) {
			callback(plugin, params.log);
		}
	});

	return state;
}

/**
 * Run Babel on a package.
 * @param {PkgDesc} pkg the package descriptor
 * @param {Array} ignore array of output-relative file paths to avoid when processing with Babel
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function runBabel(pkg) {
	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$ignore = _ref.ignore,
	    ignore = _ref$ignore === undefined ? [] : _ref$ignore;

	// Make a copy of the package's Babel configuration
	var babelConfig = cloneObject(config.babel.getConfig(pkg));

	// Tune babel config
	babelConfig.babelrc = false;
	babelConfig.only = '**/*';
	if (babelConfig.sourceMaps === undefined) {
		babelConfig.sourceMaps = true;
	}

	// Report a copy of the package's Babel configuration before loading plugins
	_report2.default.packageProcessBabelConfig(pkg, cloneObject(babelConfig));

	// Intercept presets and plugins to load them from here
	babelConfig.plugins = config.babel.loadBabelPlugins(babelConfig.presets || [], babelConfig.plugins || []);
	babelConfig.presets = [];

	// Determine files to process
	var globs = [pkg.dir + '/**/*.js'].concat(gl.negate(gl.prefix(pkg.dir + '/', ignore))).concat(['!' + pkg.dir + '/node_modules/**']);

	// Run babel through them
	var filePaths = _globby2.default.sync(globs);

	return processBabelFiles(filePaths, 0, pkg, babelConfig);
}

/**
 * Recursively process JavaScript files with Babel chunk by chunk, to maintain
 * an upper bound on the maximum number of open files so as to avoid EMFILE
 * errors.
 * @param {Array<string>} filePaths list of files to process
 * @param {number} chunkIndex
 * @param {object} pkg
 * @param {object} babelConfig
 * @return {Promise}
 */
function processBabelFiles(filePaths, chunkIndex, pkg, babelConfig) {
	var chunkSize = config.bundler.getMaxParallelFiles();

	var chunksCount = Math.floor((filePaths.length + chunkSize - 1) / chunkSize);

	var filePathsChunk = filePaths.slice(chunkIndex * chunkSize, Math.min(filePaths.length, (chunkIndex + 1) * chunkSize));

	var promises = filePathsChunk.map(function (filePath) {
		return new Promise(function (resolve) {
			var logger = new _pluginLogger2.default();

			babelIpc.set(filePath, {
				log: logger,
				rootPkgJson: (0, _readJsonSync2.default)('package.json'),
				globalConfig: cloneObject(config.getGlobalConfig())
			});

			var packageFilePath = pkg.isRoot ? filePath.substring(_path2.default.resolve(config.getOutputDir()).length + 1) : filePath.substring(filePath.indexOf(pkg.id) + pkg.id.length + 1);

			babel.transformFile(filePath, Object.assign({
				filenameRelative: filePath,
				inputSourceMap: (0, _util.loadSourceMap)(filePath)
			}, babelConfig), function (err, result) {
				// Generate and/or log results
				if (err) {
					log.error('Babel failed processing', pkg.id + '/' + packageFilePath + ':', 'it will be copied verbatim (see report file for more info)');

					logger.error('babel', err);

					_report2.default.warn('Babel failed processing some .js files: ' + 'check details of Babel transformations for more info.', { unique: true });
				} else {
					var fileName = _path2.default.basename(filePath);

					_fsExtra2.default.writeFileSync(filePath, result.code + '\n' + ('//# sourceMappingURL=' + fileName + '.map'));

					_fsExtra2.default.writeFileSync(filePath + '.map', JSON.stringify(result.map));
				}

				// Report result of babel run
				_report2.default.packageProcessBabelRun(pkg, packageFilePath, logger);

				if (logger.errorsPresent) {
					_report2.default.warn('There are errors for some of the ' + 'Babel plugins: please check details ' + 'of Babel transformations.', { unique: true });
				} else if (logger.warnsPresent) {
					_report2.default.warn('There are warnings for some of the ' + 'Babel plugins: please check details' + 'of Babel transformations.', { unique: true });
				}

				// Get rid of Babel IPC values
				babelIpc.clear(filePath);

				// Resolve promise
				resolve();
			});
		});
	});

	return Promise.all(promises).then(function () {
		chunkIndex++;

		if (chunkIndex < chunksCount) {
			return processBabelFiles(filePaths, chunkIndex, pkg, babelConfig);
		}
	});
}

/**
 * Clone a value object
 * @param  {Object} object the object to clone
 * @return {Object} a clone of the value object
 */
function cloneObject(object) {
	return JSON.parse(JSON.stringify(object));
}
//# sourceMappingURL=runners.js.map