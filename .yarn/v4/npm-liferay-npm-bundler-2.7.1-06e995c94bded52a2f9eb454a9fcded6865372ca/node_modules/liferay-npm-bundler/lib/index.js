'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (args) {
	if (args[0] === '-h' || args[0] === '--help') {
		console.log('Usage:', 'liferay-npm-bundler', '[-h|--help]', '[-v|--version]', '[-r|--dump-report]', '[-j|--create-jar]', '[--no-tracking]');
		return;
	}

	var versionsInfo = config.getVersionsInfo();

	if (args[0] === '-v' || args[0] === '--version') {
		console.log(JSON.stringify(versionsInfo, null, 2));
		return;
	}

	_report2.default.versionsInfo(versionsInfo);

	if (config.isNoTracking()) {
		run();
	} else {
		insight.init().then(run);
	}
};

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _globs = require('liferay-npm-build-tools-common/lib/globs');

var gl = _interopRequireWildcard(_globs);

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _prettyTime = require('pretty-time');

var _prettyTime2 = _interopRequireDefault(_prettyTime);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _config = require('./config');

var config = _interopRequireWildcard(_config);

var _dependencies = require('./dependencies');

var _insight = require('./insight');

var insight = _interopRequireWildcard(_insight);

var _jar = require('./jar');

var _jar2 = _interopRequireDefault(_jar);

var _log = require('./log');

var log = _interopRequireWildcard(_log);

var _manifest = require('./manifest');

var _manifest2 = _interopRequireDefault(_manifest);

var _report = require('./report');

var _report2 = _interopRequireDefault(_report);

var _runners = require('./runners');

var _util = require('./util');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Real tool execution
 * @return {void}
 */
function run() {
	try {
		var start = process.hrtime();

		// Create work directories
		var outputDir = _path2.default.resolve(config.getOutputDir());
		_fsExtra2.default.mkdirsSync(_path2.default.join(outputDir, 'node_modules'));

		var promises = [];

		// Copy project's package.json
		promises.push(bundleRootPackage(outputDir));
		_report2.default.rootPackage((0, _dependencies.getRootPkg)());

		// Grab NPM dependencies
		var pkgs = (0, _dependencies.addPackageDependencies)({}, '.', config.bundler.getIncludeDependencies());

		pkgs = Object.keys(pkgs).map(function (id) {
			return pkgs[id];
		}).filter(function (pkg) {
			return !pkg.isRoot;
		});

		_report2.default.dependencies(pkgs);
		(0, _util.reportLinkedDependencies)((0, _readJsonSync2.default)('package.json'));

		// Process NPM dependencies
		log.info('Bundling ' + pkgs.length + ' dependencies...');

		promises.push((0, _util.iterateSerially)(pkgs, function (pkg) {
			return bundlePackage(pkg, outputDir);
		}));

		// Report results
		Promise.all(promises).then(function () {
			return config.isCreateJar() ? (0, _jar2.default)() : undefined;
		}).then(function () {
			// Report and show execution time
			var hrtime = process.hrtime(start);
			_report2.default.executionTime(hrtime);
			log.info('Bundling took ' + (0, _prettyTime2.default)(hrtime));

			// Send report analytics data
			_report2.default.sendAnalytics();

			// Write report if requested
			if (config.isDumpReport()) {
				_fsExtra2.default.writeFileSync(config.getReportFilePath(), _report2.default.toHtml());
				log.info('Report written to ' + config.getReportFilePath());
			} else if (_report2.default.warningsPresent) {
				log.debug('\n*************************************************************\n\n             WARNING FROM liferay-npm-bundler\n\nThe build has emitted some warning messages: we recommend\ncleaning the output, activating the \'dump-report\' option\nin \'.npmbundlerrc\', and then reviewing the generated\n\'liferay-npm-bundler-report.html\' to make sure no problems\nwill arise during runtime.\n\n*************************************************************\n');
			}
		}).catch(abort);
	} catch (err) {
		abort(err);
	}
}

/**
 * Abort execution showing error message
 * @param  {Object} err the error object
 * @return {void}
 */


/**
 * Default entry point for the liferay-npm-bundler.
 * @param {Array} args command line arguments
 * @return {void}
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function abort(err) {
	log.error(err);
	process.exit(1);
}

/**
 * Copy project root package.json file to output directory.
 * @param {String} outputDir the output directory path
 * @return {Promise} a Promise fulfilled when the copy has been finished
 */
function bundleRootPackage(outputDir) {
	var srcPkg = (0, _dependencies.getRootPkg)();
	var pkg = srcPkg.clone({ dir: outputDir });

	if (!_manifest2.default.isOutdated(srcPkg)) {
		log.debug('Skipping root package (already bundled)');
		return Promise.resolve();
	}

	// Copy source package.json
	var srcPkgJson = (0, _readJsonSync2.default)('package.json');

	_fsExtra2.default.writeFileSync(_path2.default.join(pkg.dir, 'package.json'), JSON.stringify(srcPkgJson, '', 2));

	// Process package
	return processPackage('pre', srcPkg, pkg).then(function () {
		return (0, _runners.runBabel)(pkg, { ignore: config.babel.getIgnore() });
	}).then(function () {
		return processPackage('post', srcPkg, pkg);
	}).then(function () {
		return _manifest2.default.addPackage(srcPkg, pkg);
	}).then(function () {
		return _manifest2.default.save();
	}).then(function () {
		return log.debug('Bundled root package');
	});
}

/**
 * Bundle a npm package
 * @param {PkgDesc} srcPkg the source package descriptor
 * @param {String} outputDir directory where bundled packages are placed
 * @return {Promise} a promise that is fulfilled when the package is bundled
 */
function bundlePackage(srcPkg, outputDir) {
	if (!_manifest2.default.isOutdated(srcPkg)) {
		log.debug('Skipping ' + srcPkg.id + ' (already bundled)');
		return Promise.resolve();
	}

	log.debug('Bundling ' + srcPkg.id);

	var outPkgDir = _path2.default.join(outputDir, 'node_modules', (0, _packages.getPackageTargetDir)(srcPkg.name, srcPkg.version));

	var pkg = srcPkg.clone({ dir: outPkgDir });

	return new Promise(function (resolve, reject) {
		copyPackage(srcPkg, outPkgDir).then(function (copied) {
			if (!copied) {
				resolve();
				return;
			}

			processPackage('pre', srcPkg, pkg).then(function () {
				return (0, _runners.runBabel)(pkg);
			}).then(function () {
				return processPackage('post', srcPkg, pkg);
			}).then(function () {
				return (0, _util.renamePkgDirIfPkgJsonChanged)(pkg);
			}).then(function (pkg) {
				return _manifest2.default.addPackage(srcPkg, pkg);
			}).then(function () {
				return _manifest2.default.save();
			}).then(function () {
				return log.debug('Bundled ' + pkg.id);
			}).then(resolve).catch(reject);
		}).catch(reject);
	});
}

/**
 * Copy an NPM package to output directory.
 * @param {PkgDesc} pkg the package descriptor
 * @param {String} dir the output directory path
 * @return {Promise} a Promise fulfilled with true|false stating that the copy has been finished|rejected
 */
function copyPackage(pkg, dir) {
	var exclusions = config.bundler.getExclusions(pkg);

	// Determine what to copy
	var globs = [pkg.dir + '/**/*', '!' + pkg.dir + '/node_modules/**/*'].concat(gl.negate(gl.prefix(pkg.dir + '/', exclusions)));

	return (0, _globby2.default)(globs).then(function (files) {
		// Filter files with copy-plugins
		var state = (0, _runners.runPlugins)(config.bundler.getPlugins('copy', pkg), pkg, pkg.clone({ dir: dir }), {
			files: files
		}, function (plugin, log) {
			_report2.default.packageProcessBundlerPlugin('copy', pkg, plugin, log);
		});
		files = state.files;

		// Copy files
		var fileFilter = function fileFilter(path) {
			return _fsExtra2.default.statSync(path).isFile();
		};
		var relativePathMapper = function relativePathMapper(path) {
			return path.substring(pkg.dir.length + 1);
		};

		files = files.filter(fileFilter).map(relativePathMapper);

		var allFiles = _globby2.default.sync([pkg.dir + '/**/*']).filter(fileFilter).map(relativePathMapper);

		_report2.default.packageCopy(pkg, allFiles, files);

		if (files.length == 0) {
			return Promise.resolve(false);
		} else {
			var promises = files.map(function (path) {
				return _fsExtra2.default.copy(pkg.dir + '/' + path, dir + '/' + path);
			});

			return Promise.all(promises).then(function () {
				return true;
			});
		}
	});
}

/**
 * Process an NPM package with the configured liferay-nmp-bundler plugins. This
 * function is called two times (known as phases) per package: one before Babel
 * runs and one after.
 * @param {String} phase 'pre' or 'post' depending on what phase we are in
 * @param {PkgDesc} srcPkg the source package descriptor
 * @param {PkgDesc} pkg the target package descriptor
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function processPackage(phase, srcPkg, pkg) {
	return new Promise(function (resolve, reject) {
		try {
			var state = (0, _runners.runPlugins)(config.bundler.getPlugins(phase, pkg), srcPkg, pkg, {
				pkgJson: (0, _readJsonSync2.default)(_path2.default.join(pkg.dir, 'package.json'))
			}, function (plugin, log) {
				_report2.default.packageProcessBundlerPlugin(phase, pkg, plugin, log);

				if (log.errorsPresent) {
					_report2.default.warn('There are errors for some of the ' + 'liferay-npm-bundler plugins: please check ' + 'details of bundler transformations.', { unique: true });
				} else if (log.warnsPresent) {
					_report2.default.warn('There are warnings for some of the ' + 'liferay-npm-bundler plugins: please check ' + 'details of bundler transformations.', { unique: true });
				}
			});

			_fsExtra2.default.writeFileSync(_path2.default.join(pkg.dir, 'package.json'), JSON.stringify(state.pkgJson, '', 2));

			resolve();
		} catch (err) {
			reject(err);
		}
	});
}
//# sourceMappingURL=index.js.map