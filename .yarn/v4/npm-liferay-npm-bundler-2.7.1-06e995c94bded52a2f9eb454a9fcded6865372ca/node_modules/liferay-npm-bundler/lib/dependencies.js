'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getRootPkg = getRootPkg;
exports.addPackageDependencies = addPackageDependencies;

var _pkgDesc = require('liferay-npm-build-tools-common/lib/pkg-desc');

var _pkgDesc2 = _interopRequireDefault(_pkgDesc);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _report = require('./report');

var _report2 = _interopRequireDefault(_report);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pkgJson = (0, _readJsonSync2.default)(_path2.default.join('.', 'package.json')); /**
                                                                                      * Â© 2017 Liferay, Inc. <https://liferay.com>
                                                                                      *
                                                                                      * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                      */

var rootPkg = new _pkgDesc2.default(pkgJson.name, pkgJson.version);

/**
 * Get root package descriptor
 * @return {PkgDesc} the root package descriptor
 */
function getRootPkg() {
	return rootPkg;
}

/**
 * Recursively find the dependencies of a package and return them as PkgDesc
 * objects.
 * @param {object} collectedDependencies a hash of objects where key is the
 * 					package id and values are PkgDesc objects
 * @param {string} basedir directory where package lives in
 * @param {Array} extraDependencies an array of package names to add to
 *					dependencies collected from package.json
 * @return {object} the given collectedDependencies object
 */
function addPackageDependencies(collectedDependencies, basedir) {
	var extraDependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	var packageJson = (0, _readJsonSync2.default)(_path2.default.join(basedir, '/package.json'));
	var pkg = new _pkgDesc2.default(packageJson.name, packageJson.version, basedir == '.' ? null : basedir);

	if (collectedDependencies[pkg.id]) {
		return;
	}

	collectedDependencies[pkg.id] = pkg;

	var dependencies = packageJson.dependencies || {};
	dependencies = Object.keys(dependencies);
	dependencies = dependencies.concat(extraDependencies);

	var dependencyDirs = dependencies.map(function (dependency) {
		return resolveDependencyDir(basedir, packageJson, dependency);
	}).filter(function (dependencyDir) {
		return dependencyDir != null;
	});

	dependencyDirs.forEach(function (dependencyDir) {
		addPackageDependencies(collectedDependencies, dependencyDir);
	});

	return collectedDependencies;
}

/**
 * Resolves a dependency package and returns its directory.
 * @param {String} packageDir the base directory used for resolution
 * @param {Object} packageJson the package.json object
 * @param {String} dependency a package name
 * @return {String} the path of the directory containing the dependency package
 */
function resolveDependencyDir(packageDir, packageJson, dependency) {
	try {
		var pkgJsonFile = _resolve2.default.sync(dependency + '/package.json', {
			basedir: packageDir
		});

		return _path2.default.dirname(pkgJsonFile);
	} catch (err) {
		if (packageJson.optionalDependencies && packageJson.optionalDependencies[dependency]) {
			_report2.default.warn('Optional dependency \'' + dependency + '\' of ' + ('\'' + packageJson.name + '\' could not be found in ') + 'node_modules: it will be missing in the output bundle.');

			return null;
		} else {
			throw err;
		}
	}
}
//# sourceMappingURL=dependencies.js.map