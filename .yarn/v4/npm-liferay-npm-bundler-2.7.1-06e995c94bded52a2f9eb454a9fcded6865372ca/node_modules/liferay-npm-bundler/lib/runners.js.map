{"version":3,"sources":["../src/runners.js"],"names":["runPlugins","runBabel","babel","babelIpc","gl","config","log","plugins","srcPkg","pkg","state","callback","forEach","params","plugin","rootPkgJson","globalConfig","getGlobalConfig","clone","source","run","ignore","babelConfig","cloneObject","getConfig","babelrc","only","sourceMaps","undefined","packageProcessBabelConfig","loadBabelPlugins","presets","globs","dir","concat","negate","prefix","filePaths","sync","processBabelFiles","chunkIndex","chunkSize","bundler","getMaxParallelFiles","chunksCount","Math","floor","length","filePathsChunk","slice","min","promises","map","Promise","logger","set","filePath","packageFilePath","isRoot","substring","resolve","getOutputDir","indexOf","id","transformFile","Object","assign","filenameRelative","inputSourceMap","err","result","error","warn","unique","fileName","basename","writeFileSync","code","JSON","stringify","packageProcessBabelRun","errorsPresent","warnsPresent","clear","all","then","object","parse"],"mappings":"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","file":"runners.js","sourcesContent":["/**\n * Â© 2017 Liferay, Inc. <https://liferay.com>\n *\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\nimport * as babel from 'babel-core';\nimport fs from 'fs-extra';\nimport globby from 'globby';\nimport * as babelIpc from 'liferay-npm-build-tools-common/lib/babel-ipc';\nimport * as gl from 'liferay-npm-build-tools-common/lib/globs';\nimport PluginLogger from 'liferay-npm-build-tools-common/lib/plugin-logger';\nimport path from 'path';\nimport readJsonSync from 'read-json-sync';\n\nimport * as config from './config';\nimport * as log from './log';\nimport report from './report';\nimport {loadSourceMap} from './util';\n\n/**\n * Run a liferay-npm-bundler plugin\n * @param  {Array} plugins list of plugin descriptors (with name, config and run fields)\n * @param  {PkgDesc} srcPkg source package descriptor\n * @param  {PkgDesc} pkg processed package descriptor\n * @param  {Object} state state to pass to plugins\n * @param  {function} callback a callback function to invoke once per plugin with the used plugin and PluginLogger\n * @return {Object} the state object\n */\nexport function runPlugins(plugins, srcPkg, pkg, state, callback) {\n\tplugins.forEach(plugin => {\n\t\tconst params = {\n\t\t\tconfig: plugin.config,\n\t\t\tlog: new PluginLogger(),\n\t\t\trootPkgJson: readJsonSync('package.json'),\n\t\t\tglobalConfig: config.getGlobalConfig(),\n\n\t\t\tpkg: pkg.clone(),\n\n\t\t\tsource: {\n\t\t\t\tpkg: srcPkg.clone(),\n\t\t\t},\n\t\t};\n\n\t\tplugin.run(params, state);\n\n\t\tif (callback) {\n\t\t\tcallback(plugin, params.log);\n\t\t}\n\t});\n\n\treturn state;\n}\n\n/**\n * Run Babel on a package.\n * @param {PkgDesc} pkg the package descriptor\n * @param {Array} ignore array of output-relative file paths to avoid when processing with Babel\n * @return {Promise} a Promise fulfilled when the process has been finished\n */\nexport function runBabel(pkg, {ignore = []} = {}) {\n\t// Make a copy of the package's Babel configuration\n\tconst babelConfig = cloneObject(config.babel.getConfig(pkg));\n\n\t// Tune babel config\n\tbabelConfig.babelrc = false;\n\tbabelConfig.only = '**/*';\n\tif (babelConfig.sourceMaps === undefined) {\n\t\tbabelConfig.sourceMaps = true;\n\t}\n\n\t// Report a copy of the package's Babel configuration before loading plugins\n\treport.packageProcessBabelConfig(pkg, cloneObject(babelConfig));\n\n\t// Intercept presets and plugins to load them from here\n\tbabelConfig.plugins = config.babel.loadBabelPlugins(\n\t\tbabelConfig.presets || [],\n\t\tbabelConfig.plugins || []\n\t);\n\tbabelConfig.presets = [];\n\n\t// Determine files to process\n\tconst globs = [`${pkg.dir}/**/*.js`]\n\t\t.concat(gl.negate(gl.prefix(`${pkg.dir}/`, ignore)))\n\t\t.concat([`!${pkg.dir}/node_modules/**`]);\n\n\t// Run babel through them\n\tconst filePaths = globby.sync(globs);\n\n\treturn processBabelFiles(filePaths, 0, pkg, babelConfig);\n}\n\n/**\n * Recursively process JavaScript files with Babel chunk by chunk, to maintain\n * an upper bound on the maximum number of open files so as to avoid EMFILE\n * errors.\n * @param {Array<string>} filePaths list of files to process\n * @param {number} chunkIndex\n * @param {object} pkg\n * @param {object} babelConfig\n * @return {Promise}\n */\nfunction processBabelFiles(filePaths, chunkIndex, pkg, babelConfig) {\n\tconst chunkSize = config.bundler.getMaxParallelFiles();\n\n\tconst chunksCount = Math.floor(\n\t\t(filePaths.length + chunkSize - 1) / chunkSize\n\t);\n\n\tconst filePathsChunk = filePaths.slice(\n\t\tchunkIndex * chunkSize,\n\t\tMath.min(filePaths.length, (chunkIndex + 1) * chunkSize)\n\t);\n\n\tconst promises = filePathsChunk.map(\n\t\tfilePath =>\n\t\t\tnew Promise(resolve => {\n\t\t\t\tconst logger = new PluginLogger();\n\n\t\t\t\tbabelIpc.set(filePath, {\n\t\t\t\t\tlog: logger,\n\t\t\t\t\trootPkgJson: readJsonSync('package.json'),\n\t\t\t\t\tglobalConfig: cloneObject(config.getGlobalConfig()),\n\t\t\t\t});\n\n\t\t\t\tconst packageFilePath = pkg.isRoot\n\t\t\t\t\t? filePath.substring(\n\t\t\t\t\t\t\tpath.resolve(config.getOutputDir()).length + 1\n\t\t\t\t\t  )\n\t\t\t\t\t: filePath.substring(\n\t\t\t\t\t\t\tfilePath.indexOf(pkg.id) + pkg.id.length + 1\n\t\t\t\t\t  );\n\n\t\t\t\tbabel.transformFile(\n\t\t\t\t\tfilePath,\n\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfilenameRelative: filePath,\n\t\t\t\t\t\t\tinputSourceMap: loadSourceMap(filePath),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tbabelConfig\n\t\t\t\t\t),\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t// Generate and/or log results\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlog.error(\n\t\t\t\t\t\t\t\t'Babel failed processing',\n\t\t\t\t\t\t\t\t`${pkg.id}/${packageFilePath}:`,\n\t\t\t\t\t\t\t\t'it will be copied verbatim (see report file for more info)'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tlogger.error('babel', err);\n\n\t\t\t\t\t\t\treport.warn(\n\t\t\t\t\t\t\t\t'Babel failed processing some .js files: ' +\n\t\t\t\t\t\t\t\t\t'check details of Babel transformations for more info.',\n\t\t\t\t\t\t\t\t{unique: true}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst fileName = path.basename(filePath);\n\n\t\t\t\t\t\t\tfs.writeFileSync(\n\t\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t\t`${result.code}\\n` +\n\t\t\t\t\t\t\t\t\t`//# sourceMappingURL=${fileName}.map`\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfs.writeFileSync(\n\t\t\t\t\t\t\t\t`${filePath}.map`,\n\t\t\t\t\t\t\t\tJSON.stringify(result.map)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Report result of babel run\n\t\t\t\t\t\treport.packageProcessBabelRun(\n\t\t\t\t\t\t\tpkg,\n\t\t\t\t\t\t\tpackageFilePath,\n\t\t\t\t\t\t\tlogger\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (logger.errorsPresent) {\n\t\t\t\t\t\t\treport.warn(\n\t\t\t\t\t\t\t\t'There are errors for some of the ' +\n\t\t\t\t\t\t\t\t\t'Babel plugins: please check details ' +\n\t\t\t\t\t\t\t\t\t'of Babel transformations.',\n\t\t\t\t\t\t\t\t{unique: true}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (logger.warnsPresent) {\n\t\t\t\t\t\t\treport.warn(\n\t\t\t\t\t\t\t\t'There are warnings for some of the ' +\n\t\t\t\t\t\t\t\t\t'Babel plugins: please check details' +\n\t\t\t\t\t\t\t\t\t'of Babel transformations.',\n\t\t\t\t\t\t\t\t{unique: true}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get rid of Babel IPC values\n\t\t\t\t\t\tbabelIpc.clear(filePath);\n\n\t\t\t\t\t\t// Resolve promise\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t})\n\t);\n\n\treturn Promise.all(promises).then(() => {\n\t\tchunkIndex++;\n\n\t\tif (chunkIndex < chunksCount) {\n\t\t\treturn processBabelFiles(filePaths, chunkIndex, pkg, babelConfig);\n\t\t}\n\t});\n}\n\n/**\n * Clone a value object\n * @param  {Object} object the object to clone\n * @return {Object} a clone of the value object\n */\nfunction cloneObject(object) {\n\treturn JSON.parse(JSON.stringify(object));\n}\n"]}