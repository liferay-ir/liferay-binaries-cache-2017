'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.transformPreferences = transformPreferences;
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * Transform a preferences.json file into a DDM form JSON definition
 * @param {object} preferencesJson a preferences JSON object
 * @return {object} a DDM form JSON object
 */
function transformPreferences(preferencesJson) {
	return {
		availableLanguageIds: [],
		fields: Object.entries(preferencesJson.fields).map(function (_ref) {
			var _ref2 = _slicedToArray(_ref, 2),
			    name = _ref2[0],
			    props = _ref2[1];

			var field = {
				name: name,
				label: localized(props.name || name)
			};

			Object.assign(field, getTypeProps(props));

			if (props.description) {
				field.tip = localized(props.description);
			}

			if (props.default) {
				field.predefinedValue = getPredefinedValue(props);
			}

			if (props.required !== undefined) {
				field.required = props.required;
			}

			if (props.options) {
				field.options = [];

				Object.entries(props.options).forEach(function (_ref3) {
					var _ref4 = _slicedToArray(_ref3, 2),
					    key = _ref4[0],
					    value = _ref4[1];

					field.options.push({
						value: key,
						label: localized(value)
					});
				});
			}

			return field;
		})
	};
}

/**
 * Get a predefinedValue DDM object for a given field
 * @param {object} props the field props (in preferences.json format)
 * @return {*} the predefinedValue DDM object
 */
function getPredefinedValue(props) {
	if (props.options) {
		// DDM uses JSON inside a JSON, so we do this to make sure this code is
		// maintenable and doesn't break anything
		var json = JSON.stringify({ value: [props.default] }, null, 0);

		json = json.replace(/{"value":(.*)}/, '$1');

		return localized(json);
	} else {
		return localized(props.default);
	}
}

/**
 * Get the dataType and type DDM properties of a given field
 * @param {object} props the field props (in preferences.json format)
 * @return {object} an object containing the dataType and type properties
 */
function getTypeProps(props) {
	if (props.options) {
		return {
			dataType: 'string',
			type: 'select'
		};
	}

	switch (props.type) {
		case 'string':
			return {
				dataType: 'string',
				type: 'text'
			};

		case 'number':
			return {
				dataType: 'number',
				type: 'ddm-number'
			};

		case 'float':
			return {
				dataType: 'double',
				type: 'ddm-decimal'
			};

		case 'boolean':
			return {
				dataType: 'boolean',
				type: 'checkbox'
			};

		case 'password':
			throw new Error('Password fields are not supported in preferences');

		default:
			throw new Error('Unknown field type: ' + props.type);
	}
}

/**
 * Transform a string into a localized DDM value (the string is used as the
 * default locale value)
 * @param {string} string the string to localize
 * @return {object} the DDM localized value
 */
function localized(string) {
	return {
		'': string
	};
}
//# sourceMappingURL=ddm.js.map