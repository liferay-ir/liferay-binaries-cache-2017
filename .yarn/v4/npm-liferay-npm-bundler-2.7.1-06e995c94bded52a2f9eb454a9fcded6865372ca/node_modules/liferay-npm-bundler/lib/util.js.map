{"version":3,"sources":["../src/util.js"],"names":["iterateSerially","loadSourceMap","renamePkgDirIfPkgJsonChanged","reportLinkedDependencies","values","asyncProcess","Promise","length","resolve","val","p","then","slice","filePath","fileContent","readFileSync","offset1","lastIndexOf","offset2","offset","Math","max","annotation","toString","substring","matches","match","url","indexOf","parsedData","body","mimeType","JSON","parse","sourceMapFile","normalize","join","dirname","err","pkg","pkgJson","dir","outputDir","name","version","newDir","move","isRoot","forEach","scope","Object","keys","depVersion","depName","validRange","depPkgJsonPath","depPkgJson","linkedDependency"],"mappings":"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","file":"util.js","sourcesContent":["/**\n * Â© 2017 Liferay, Inc. <https://liferay.com>\n *\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\nimport parseDataURL from 'data-urls';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport readJsonSync from 'read-json-sync';\nimport semver from 'semver';\n\nimport {getPackageTargetDir} from 'liferay-npm-build-tools-common/lib/packages';\nimport PkgDesc from 'liferay-npm-build-tools-common/lib/pkg-desc';\nimport report from './report';\n\n/**\n * Iterate through the elements of an array applying an async process serially\n * to each one of them.\n * @param {Array} values array of values to be iterated\n * @param {function} asyncProcess the async process (that returns a Promise) to\n *        be executed on each value\n * @return {Promise} a Promise that is resolved as soon as the iteration\n *         finishes\n */\nexport function iterateSerially(values, asyncProcess) {\n\treturn new Promise(resolve => {\n\t\tif (values.length == 0) {\n\t\t\tresolve();\n\t\t\treturn;\n\t\t}\n\n\t\tconst val = values[0];\n\n\t\tconst p = asyncProcess(val);\n\n\t\tp.then(() => {\n\t\t\titerateSerially(values.slice(1), asyncProcess).then(() => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Load the source map of a transpiled JS file.\n * @param  {string} filePath the path to the transpiled JS file\n * @return {Object|null} the source map object or null if not present\n */\nexport function loadSourceMap(filePath) {\n\tconst fileContent = fs.readFileSync(filePath);\n\n\tconst offset1 = fileContent.lastIndexOf('//# sourceMappingURL=');\n\tconst offset2 = fileContent.lastIndexOf('/*# sourceMappingURL=');\n\n\tconst offset = Math.max(offset1, offset2);\n\n\tconst annotation = fileContent.toString().substring(offset);\n\n\tlet matches = annotation.match(/\\/\\/# sourceMappingURL=(.*)/);\n\tif (!matches) {\n\t\tmatches = annotation.match(/\\/\\*# sourceMappingURL=(.*) \\*\\//);\n\n\t\tif (!matches) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst url = matches[1];\n\n\tif (url.indexOf('data:') == 0) {\n\t\tconst parsedData = parseDataURL(url);\n\n\t\tif (parsedData) {\n\t\t\tconst {body, mimeType} = parsedData;\n\n\t\t\tif (mimeType.toString() === 'application/json') {\n\t\t\t\treturn JSON.parse(body.toString());\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst sourceMapFile = path.normalize(\n\t\t\tpath.join(path.dirname(filePath), url)\n\t\t);\n\n\t\ttry {\n\t\t\treturn readJsonSync(sourceMapFile);\n\t\t} catch (err) {\n\t\t\t// Swallow.\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * Rename a package folder if package.json doesn't match original package name\n * or version.\n * @param {PkgDesc} pkg the package descriptor\n * @return {Promise} a Promise that returns the modified PkgDesc\n */\nexport function renamePkgDirIfPkgJsonChanged(pkg) {\n\tconst pkgJson = readJsonSync(path.join(pkg.dir, 'package.json'));\n\tconst outputDir = path.dirname(pkg.dir);\n\n\tif (pkgJson.name !== pkg.name || pkgJson.version !== pkg.version) {\n\t\tconst newDir = path.join(\n\t\t\toutputDir,\n\t\t\tgetPackageTargetDir(pkgJson.name, pkgJson.version)\n\t\t);\n\n\t\treturn fs\n\t\t\t.move(pkg.dir, newDir)\n\t\t\t.then(\n\t\t\t\t() =>\n\t\t\t\t\tnew PkgDesc(\n\t\t\t\t\t\tpkgJson.name,\n\t\t\t\t\t\tpkgJson.version,\n\t\t\t\t\t\tnewDir,\n\t\t\t\t\t\tpkg.isRoot\n\t\t\t\t\t)\n\t\t\t);\n\t}\n\n\treturn Promise.resolve(pkg);\n}\n\n/**\n * Report linked dependencies of a given package.json\n * @param  {Object} pkgJson pacakge.json file contents\n * @return {void}\n */\nexport function reportLinkedDependencies(pkgJson) {\n\t['dependencies', 'devDependencies'].forEach(scope => {\n\t\tif (pkgJson[scope] != null) {\n\t\t\tObject.keys(pkgJson[scope]).forEach(depName => {\n\t\t\t\tconst depVersion = pkgJson[scope][depName];\n\n\t\t\t\tif (semver.validRange(depVersion) == null) {\n\t\t\t\t\tconst depPkgJsonPath = path.join(\n\t\t\t\t\t\t'node_modules',\n\t\t\t\t\t\tdepName,\n\t\t\t\t\t\t'package.json'\n\t\t\t\t\t);\n\n\t\t\t\t\tconst depPkgJson = readJsonSync(depPkgJsonPath);\n\n\t\t\t\t\tpkgJson[scope][depName] = depPkgJson.version;\n\n\t\t\t\t\treport.linkedDependency(\n\t\t\t\t\t\tdepName,\n\t\t\t\t\t\tdepVersion,\n\t\t\t\t\t\tdepPkgJson.version\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n"]}