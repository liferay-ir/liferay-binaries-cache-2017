'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.jar = exports.bundler = exports.babel = undefined;
exports.getGlobalConfig = getGlobalConfig;
exports.getOutputDir = getOutputDir;
exports.getReportFilePath = getReportFilePath;
exports.getVersionsInfo = getVersionsInfo;
exports.isCreateJar = isCreateJar;
exports.isDumpReport = isDumpReport;
exports.isNoTracking = isNoTracking;
exports.isVerbose = isVerbose;
exports.reloadConfig = reloadConfig;
exports.setProgramArgs = setProgramArgs;

var _dotProp = require('dot-prop');

var _dotProp2 = _interopRequireDefault(_dotProp);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _merge = require('merge');

var _merge2 = _interopRequireDefault(_merge);

var _babel = require('./internal/babel');

var babel = _interopRequireWildcard(_babel);

var _bundler = require('./internal/bundler');

var bundler = _interopRequireWildcard(_bundler);

var _jar = require('./internal/jar');

var jar = _interopRequireWildcard(_jar);

var _util = require('./internal/util');

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// These state objects are consts so that they can be injected into private
// submodules just once.
var config = {}; /**
                  * Â© 2017 Liferay, Inc. <https://liferay.com>
                  *
                  * SPDX-License-Identifier: LGPL-3.0-or-later
                  */

var pkgJson = {};
var savedProgramArgs = [];

// Inject configuration in private submodules
babel.init({ config: config, pkgJson: pkgJson });
bundler.init({ config: config, pkgJson: pkgJson });
jar.init({ config: config, pkgJson: pkgJson });
util.init({ config: config, pkgJson: pkgJson });

// Load things for the first time
loadConfig();
loadPkgJson();

// Reexport private modules as namespaced configuration
exports.babel = babel;
exports.bundler = bundler;
exports.jar = jar;

/**
 * Get global plugins configuration.
 * @return {Object} the global config hash
 */

function getGlobalConfig() {
	return _dotProp2.default.get(config, 'config');
}

/**
 * Get the configured output directory
 * @return {String} the directory path (with native separators)
 */
function getOutputDir() {
	var dir = _dotProp2.default.get(config, 'output', isCreateJar() ? 'build' : 'build/resources/main/META-INF/resources');

	return _path2.default.normalize(dir);
}

/**
 * Get the path to the report file or null if no report is configured.
 * @return {String} a normalized path or null
 */
function getReportFilePath() {
	return _path2.default.join('.', 'liferay-npm-bundler-report.html');
}

/**
 * Get versions information
 * @return {void}
 */
function getVersionsInfo() {
	var pkgJson = require('../../package.json');

	var info = {
		'liferay-npm-bundler': pkgJson.version
	};

	info = Object.assign(info, getPluginVersions());

	return info;
}

/**
 * Whether or not to create an OSGi bundle
 * @return {boolean}
 */
function isCreateJar() {
	return _dotProp2.default.get(config, 'create-jar', false);
}

/**
 * Whether or not to dump report
 * @return {boolean}
 */
function isDumpReport() {
	return _dotProp2.default.get(config, 'dump-report', false);
}

/**
 * Whether or not to track usage
 * @return {boolean}
 */
function isNoTracking() {
	if (!_dotProp2.default.has(config, 'no-tracking')) {
		if (_dotProp2.default.has(process, 'env.LIFERAY_NPM_BUNDLER_NO_TRACKING')) {
			_dotProp2.default.set(config, 'no-tracking', true);
		}
	}

	if (!_dotProp2.default.has(config, 'no-tracking')) {
		var dir = process.cwd();

		while (!_fs2.default.existsSync(_path2.default.join(dir, '.liferay-npm-bundler-no-tracking')) && _path2.default.resolve(dir, '..') !== dir) {
			dir = _path2.default.resolve(dir, '..');
		}

		_dotProp2.default.set(config, 'no-tracking', _fs2.default.existsSync(_path2.default.join(dir, '.liferay-npm-bundler-no-tracking')));
	}

	return _dotProp2.default.get(config, 'no-tracking', false);
}

/**
 * Whether or not to dump detailed information about what the tool is doing
 * @return {boolean}
 */
function isVerbose() {
	return _dotProp2.default.get(config, 'verbose', false);
}

/**
 * Force a config reload
 * @return {void}
 */
function reloadConfig() {
	loadConfig();
	loadPkgJson();
	setProgramArgs(savedProgramArgs);
}

/**
 * Set CLI arguments to be able to override some .npmbundlerrc options.
 * @param {Array} args passed in CLI arguments
 */
function setProgramArgs(args) {
	savedProgramArgs.length = 0;
	savedProgramArgs.push(args);

	if (args.includes('-j') || args.includes('--create-jar')) {
		config['create-jar'] = true;
	}

	if (args.includes('-r') || args.includes('--dump-report')) {
		config['dump-report'] = true;
	}

	if (args.includes('--no-tracking')) {
		config['no-tracking'] = true;
	}
}

/**
 * Add version numbers for all bundler and Babel plugins listed in `cfg`.
 * @param {Array} plugins the array of currently collected plugins
 * @param {Array} cfg a configuration subsection
 * @return {Array} the concatenated array of collected plugins
 */
function concatAllPlugins(plugins, cfg) {
	if (cfg) {
		plugins = concatBundlerPlugins(plugins, cfg['plugins']);
		plugins = concatBundlerPlugins(plugins, cfg['post-plugins']);
		plugins = concatBabelPlugins(plugins, cfg['.babelrc']);
	}

	return plugins;
}

/**
 * Add version numbers for all Babel plugins listed in `cfg`.
 * @param {Array} plugins the array of currently collected plugins
 * @param {Array} cfg a configuration subsection
 * @return {Array} the concatenated array of collected plugins
 */
function concatBabelPlugins(plugins, cfg) {
	if (!cfg) {
		return plugins;
	}

	var babelPresets = cfg['presets'];
	var babelPlugins = cfg['plugins'];

	if (babelPresets) {
		plugins = plugins.concat(babelPresets.map(function (name) {
			try {
				util.configRequire(name);
				return name;
			} catch (err) {
				return 'babel-preset-' + name;
			}
		}));
	}

	if (babelPlugins) {
		plugins = plugins.concat(babelPlugins.map(function (name) {
			if (Array.isArray(name)) {
				name = name[0];
			}

			try {
				util.configRequire(name);
				return name;
			} catch (err) {
				return 'babel-plugin-' + name;
			}
		}));
	}

	return plugins;
}

/**
 * Add version numbers for all bundler plugins listed in `cfg`.
 * @param {Array} plugins the array of currently collected plugins
 * @param {Array} cfg a configuration subsection
 * @return {Array} the concatenated array of collected plugins
 */
function concatBundlerPlugins(plugins, cfg) {
	if (!cfg) {
		return plugins;
	}

	return plugins.concat(cfg.map(function (name) {
		if (Array.isArray(name)) {
			name = name[0];
		}

		return 'liferay-npm-bundler-plugin-' + name;
	}));
}

/**
 * Get version numbers of all plugins used in the build.
 * @return {Object} a map of {plugin-name: version} values
 */
function getPluginVersions() {
	var pluginVersions = {};

	// Get preset plugin version
	if (config.preset) {
		var _pkgJson = util.configRequire(config.preset + '/package.json');

		pluginVersions[config.preset] = _pkgJson.version;
	}

	// Get legacy package and package plugins versions
	var plugins = [];

	for (var key in config) {
		if (config.hasOwnProperty(key)) {
			plugins = concatAllPlugins(plugins, config[key]);
		}
	}

	for (var _key in config.packages) {
		if (config.packages.hasOwnProperty(_key)) {
			plugins = concatAllPlugins(plugins, config.packages[_key]);
		}
	}

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var plugin = _step.value;

			if (!pluginVersions[plugin]) {
				var _pkgJson2 = util.configRequire(plugin + '/package.json');

				pluginVersions[plugin] = _pkgJson2.version;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return pluginVersions;
}

/**
 * Load configuration from current work dir into config object.
 * @return {void}
 */
function loadConfig() {
	// Clean configuration
	for (var key in config) {
		if (config.hasOwnProperty(key)) {
			delete config[key];
		}
	}

	// Load base configuration
	try {
		Object.assign(config, (0, _readJsonSync2.default)('.npmbundlerrc'));
	} catch (err) {
		if (err.code !== 'ENOENT') {
			throw err;
		}
	}

	// Store plugins base dir
	config.pluginsBaseDir = _path2.default.resolve('.');

	// Apply preset if necessary
	var presetFile = void 0;

	if (config.preset === undefined) {
		presetFile = require.resolve('liferay-npm-bundler-preset-standard');
	} else if (config.preset === '' || config.preset === false) {
		// don't load preset
	} else {
		presetFile = _resolve2.default.sync(config.preset, {
			basedir: '.'
		});
	}

	if (presetFile) {
		var originalConfig = Object.assign({}, config);
		Object.assign(config, _merge2.default.recursive((0, _readJsonSync2.default)(presetFile), originalConfig));
		config.pluginsBaseDir = (0, _packages.getPackageDir)(presetFile);
	}

	// Normalize
	config['/'] = config['/'] || {};
	config['config'] = config['config'] || {};
	config.packages = config.packages || {};
}

/**
 * Load package.json from current work dir into config object.
 * @return {void}
 */
function loadPkgJson() {
	// Clean pkgJson
	for (var key in pkgJson) {
		if (pkgJson.hasOwnProperty(key)) {
			delete pkgJson[key];
		}
	}

	Object.assign(pkgJson, (0, _readJsonSync2.default)('package.json'));
}
//# sourceMappingURL=index.js.map