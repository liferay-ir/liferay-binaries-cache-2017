'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.iterateSerially = iterateSerially;
exports.loadSourceMap = loadSourceMap;
exports.renamePkgDirIfPkgJsonChanged = renamePkgDirIfPkgJsonChanged;
exports.reportLinkedDependencies = reportLinkedDependencies;

var _dataUrls = require('data-urls');

var _dataUrls2 = _interopRequireDefault(_dataUrls);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _pkgDesc = require('liferay-npm-build-tools-common/lib/pkg-desc');

var _pkgDesc2 = _interopRequireDefault(_pkgDesc);

var _report = require('./report');

var _report2 = _interopRequireDefault(_report);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Iterate through the elements of an array applying an async process serially
 * to each one of them.
 * @param {Array} values array of values to be iterated
 * @param {function} asyncProcess the async process (that returns a Promise) to
 *        be executed on each value
 * @return {Promise} a Promise that is resolved as soon as the iteration
 *         finishes
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function iterateSerially(values, asyncProcess) {
	return new Promise(function (resolve) {
		if (values.length == 0) {
			resolve();
			return;
		}

		var val = values[0];

		var p = asyncProcess(val);

		p.then(function () {
			iterateSerially(values.slice(1), asyncProcess).then(function () {
				resolve();
			});
		});
	});
}

/**
 * Load the source map of a transpiled JS file.
 * @param  {string} filePath the path to the transpiled JS file
 * @return {Object|null} the source map object or null if not present
 */
function loadSourceMap(filePath) {
	var fileContent = _fsExtra2.default.readFileSync(filePath);

	var offset1 = fileContent.lastIndexOf('//# sourceMappingURL=');
	var offset2 = fileContent.lastIndexOf('/*# sourceMappingURL=');

	var offset = Math.max(offset1, offset2);

	var annotation = fileContent.toString().substring(offset);

	var matches = annotation.match(/\/\/# sourceMappingURL=(.*)/);
	if (!matches) {
		matches = annotation.match(/\/\*# sourceMappingURL=(.*) \*\//);

		if (!matches) {
			return null;
		}
	}

	var url = matches[1];

	if (url.indexOf('data:') == 0) {
		var parsedData = (0, _dataUrls2.default)(url);

		if (parsedData) {
			var body = parsedData.body,
			    mimeType = parsedData.mimeType;


			if (mimeType.toString() === 'application/json') {
				return JSON.parse(body.toString());
			}
		}
	} else {
		var sourceMapFile = _path2.default.normalize(_path2.default.join(_path2.default.dirname(filePath), url));

		try {
			return (0, _readJsonSync2.default)(sourceMapFile);
		} catch (err) {
			// Swallow.
		}
	}

	return null;
}

/**
 * Rename a package folder if package.json doesn't match original package name
 * or version.
 * @param {PkgDesc} pkg the package descriptor
 * @return {Promise} a Promise that returns the modified PkgDesc
 */
function renamePkgDirIfPkgJsonChanged(pkg) {
	var pkgJson = (0, _readJsonSync2.default)(_path2.default.join(pkg.dir, 'package.json'));
	var outputDir = _path2.default.dirname(pkg.dir);

	if (pkgJson.name !== pkg.name || pkgJson.version !== pkg.version) {
		var newDir = _path2.default.join(outputDir, (0, _packages.getPackageTargetDir)(pkgJson.name, pkgJson.version));

		return _fsExtra2.default.move(pkg.dir, newDir).then(function () {
			return new _pkgDesc2.default(pkgJson.name, pkgJson.version, newDir, pkg.isRoot);
		});
	}

	return Promise.resolve(pkg);
}

/**
 * Report linked dependencies of a given package.json
 * @param  {Object} pkgJson pacakge.json file contents
 * @return {void}
 */
function reportLinkedDependencies(pkgJson) {
	['dependencies', 'devDependencies'].forEach(function (scope) {
		if (pkgJson[scope] != null) {
			Object.keys(pkgJson[scope]).forEach(function (depName) {
				var depVersion = pkgJson[scope][depName];

				if (_semver2.default.validRange(depVersion) == null) {
					var depPkgJsonPath = _path2.default.join('node_modules', depName, 'package.json');

					var depPkgJson = (0, _readJsonSync2.default)(depPkgJsonPath);

					pkgJson[scope][depName] = depPkgJson.version;

					_report2.default.linkedDependency(depName, depVersion, depPkgJson.version);
				}
			});
		}
	});
}
//# sourceMappingURL=util.js.map