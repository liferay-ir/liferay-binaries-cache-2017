'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Manifest = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Â© 2017 Liferay, Inc. <https://liferay.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SPDX-License-Identifier: LGPL-3.0-or-later
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _config = require('./config');

var config = _interopRequireWildcard(_config);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class to hold information about processed modules and optionally dump/read
 * it to/from disk.
 * @type {Manifest}
 */
var Manifest = exports.Manifest = function () {
	/**
  * Constructor
  * @param {String} filePath an optional path to a file to load initial status
  */
	function Manifest() {
		var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

		_classCallCheck(this, Manifest);

		if (filePath) {
			this._filePath = filePath;

			try {
				this._data = JSON.parse(_fs2.default.readFileSync(filePath));
				return;
			} catch (err) {
				if (err.code !== 'ENOENT') {
					throw err;
				}
			}
		}

		this._data = {
			packages: {}
		};
	}

	/**
  * Add a processed package entry
  * @param {PkgDesc} srcPkg the source package descriptor
  * @param {PkgDesc} destPkg the destination package descriptor
  */


	_createClass(Manifest, [{
		key: 'addPackage',
		value: function addPackage(srcPkg, destPkg) {
			var cwd = process.cwd();

			this._data.packages[srcPkg.id] = {
				src: {
					id: srcPkg.id,
					name: srcPkg.name,
					version: srcPkg.version,
					dir: '.' + _path2.default.resolve(srcPkg.dir).substring(cwd.length)
				},
				dest: {
					id: destPkg.id,
					name: destPkg.name,
					version: destPkg.version,
					dir: '.' + _path2.default.resolve(destPkg.dir).substring(cwd.length)
				}
			};
		}

		/**
   * Get a processed package entry
   * @param {PkgDesc} srcPkg the source package descriptor
   * @return {Object} the processed package entry (see addPackage for format description)
   */

	}, {
		key: 'getPackage',
		value: function getPackage(srcPkg) {
			return this._data.packages[srcPkg.id];
		}

		/**
   * Tests whether a package must be regenerated
   * @param {PkgDesc} srcPkg the source package descriptor
   * @return {Boolean} true if package is outdated
   */

	}, {
		key: 'isOutdated',
		value: function isOutdated(srcPkg) {
			// Unless we use real timestamps or digests, we cannot detect reliably
			// if the root package is outdated or up-to-date.
			if (srcPkg.isRoot) {
				return true;
			}

			var entry = this._data.packages[srcPkg.id];

			if (entry === undefined) {
				return true;
			}

			if (!_fs2.default.existsSync(entry.dest.dir)) {
				return true;
			}

			return false;
		}

		/**
   * Save current manifest to a file
   * @param  {String} filePath path to file or null to use default path
   * @return {void}
   */

	}, {
		key: 'save',
		value: function save() {
			var filePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

			filePath = filePath || this._filePath;

			if (filePath === undefined) {
				throw new Error('No file path given and no default path set');
			}

			_fs2.default.writeFileSync(filePath, this.toJSON());
		}

		/**
   * Return the JSON serialization of this manifest
   * @return {String}
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			return JSON.stringify(this._data, null, 2);
		}
	}]);

	return Manifest;
}();

var manifest = new Manifest(_path2.default.join(config.getOutputDir(), 'manifest.json'));

exports.default = manifest;
//# sourceMappingURL=manifest.js.map