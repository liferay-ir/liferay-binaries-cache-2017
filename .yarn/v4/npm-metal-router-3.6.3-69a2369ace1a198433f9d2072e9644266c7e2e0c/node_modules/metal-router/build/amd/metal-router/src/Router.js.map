{"version":3,"sources":["Router.js"],"names":["Router","route","path","createScreen_","bind","router","addRoutes","firstRenderElement","element","state","includeRoutingData","params","lastExtractedParams","extractParams","query","extractQuery","mixin","currentUrl","wasRendered","screen_","defaultScreen","activeRouter","removeRoute","uri","queryStrings","parameterNames","getParameterNames","i","length","name","getParameterValue","components","comp","isActive_","elementVoid","component","toArray_","activeState","ctor","isString","getConstructor","changes","config","arr","keys","Object","push","getRouteComponent","routerInstance","app","setIgnoreQueryStringFromRoutePath","RENDERER","STATE","beforeDeactivateHandler","validator","val","isFunction","cacheable","isBoolean","value","setter","data","fetch","fetchUrl","fetchTimeout","isNumber","isDefAndNotNull","internal","ComponentScreen","Error","timeout","handler","compName","maybeRedirectRouter","addRoutingData","lastPath","maybeParseLastLoadedStateAsJson","reuseActiveRouterElementInNewRouter_","deferred","waitRouterRenderSubComponents","fetchPath","setCacheable","resolve","then","getFetchUrl_","loadedState","lastRedirectPath","maybeFindRedirectPath","lastLoadedState","redirectPath","beforeUpdateHistoryPath","redirectRoute","findRoute","JSON","parse","err","redirectRouter","maybeFindRedirectRouter","once","screens","activePath","Promise","res"],"mappings":"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","file":"src/Router.js","sourcesContent":["'use strict';\n\nimport { core, getFunctionName, object } from 'metal';\nimport { App, RequestScreen, Route } from 'senna';\nimport CancellablePromise from 'metal-promise';\nimport { Component, ComponentRegistry } from 'metal-component';\nimport IncrementalDomRenderer from 'metal-incremental-dom';\nimport Uri from 'metal-uri';\n\n/**\n * Router class responsible for routing links to components.\n */\nclass Router extends Component {\n\t/**\n\t * @inheritDoc\n\t */\n\tcreated() {\n\t\tthis.route = new Route(this.path, this.createScreen_.bind(this));\n\t\tthis.route.router = this;\n\t\tRouter.router().addRoutes(this.route);\n\n\t\t// Router is never active on the first render, since it needs to wait for\n\t\t// any async data to load first. This code is to make sure it won't lose\n\t\t// the reference to its `element` and cause it to be removed from the dom\n\t\t// (which would be bad for progressive enhancement) due to not rendering\n\t\t// anything. It will be set back in `attached`.\n\t\tthis.firstRenderElement = this.element;\n\t\tthis.element = null;\n\t}\n\n\t/**\n\t * Adds routing data to the given state object.\n\t * @param {string} path\n\t * @param {!Object} state\n\t * @return {!Object}\n\t */\n\taddRoutingData(path, state) {\n\t\tif (this.includeRoutingData) {\n\t\t\tconst params = this.lastExtractedParams || this.extractParams(path);\n\t\t\tconst query = this.extractQuery(path);\n\t\t\treturn object.mixin({}, state, {\n\t\t\t\trouter: {\n\t\t\t\t\tcurrentUrl: path,\n\t\t\t\t\tparams,\n\t\t\t\t\tquery\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn state;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tattached() {\n\t\tif (!this.wasRendered) {\n\t\t\tthis.element = this.firstRenderElement;\n\t\t}\n\t}\n\n\t/**\n\t * Creates the screen to be used by this router.\n\t * @protected\n\t */\n\tcreateScreen_() {\n\t\tthis.screen_ = new Router.defaultScreen(this);\n\t\treturn this.screen_;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tif (Router.activeRouter === this) {\n\t\t\tRouter.activeRouter = null;\n\t\t}\n\t\tRouter.router().removeRoute(this.route);\n\t\tsuper.disposeInternal();\n\t}\n\n\t/**\n\t * Extracts any params present in the given path.\n\t * @param {string} path\n\t * @return {Object}\n\t */\n\textractParams(path) {\n\t\treturn Router.router().extractParams(this.route, path);\n\t}\n\n\t/**\n\t * Extracts any query params present in the given path.\n\t * @param {string} path\n\t * @return {Object}\n\t */\n\textractQuery(path) {\n\t\tconst uri = new Uri(path);\n\t\tconst queryStrings = {};\n\n\t\tconst parameterNames = uri.getParameterNames();\n\n\t\tfor (let i = 0; i < parameterNames.length; i++) {\n\t\t\tconst name = parameterNames[i];\n\n\t\t\tqueryStrings[name] = uri.getParameterValue(name);\n\t\t}\n\n\t\treturn queryStrings;\n\t}\n\n\t/**\n\t * Gets the currently active component from the current router.\n\t * @return {Component}\n\t */\n\tstatic getActiveComponent() {\n\t\treturn Router.activeRouter ? Router.activeRouter.getRouteComponent() : null;\n\t}\n\n\t/**\n\t * Gets the state for the currently active component.\n\t * @return {Object}\n\t */\n\tstatic getActiveState() {\n\t\treturn Router.activeState;\n\t}\n\n\t/**\n\t * Gets this router's component, if there is one.\n\t * @return {Component}\n\t */\n\tgetRouteComponent() {\n\t\treturn this.components.comp;\n\t}\n\n\t/**\n\t * Gets the screen that is being used by this router.\n\t */\n\tgetScreen() {\n\t\treturn this.screen_;\n\t}\n\n\t/**\n\t * Renders the component, if the current path is active, or nothing otherwise.\n\t */\n\trender() {\n\t\tif (this.isActive_) {\n\t\t\tIncrementalDOM.elementVoid(\n\t\t\t\tthis.component,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t'ref',\n\t\t\t\t'comp',\n\t\t\t\t...this.toArray_(Router.activeState)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the single Senna.js application that handles all `Router`\n\t * instances, creating it if it hasn't been built yet.\n\t * @return {!App}\n\t * @static\n\t */\n\tstatic router() {\n\t\tif (!Router.routerInstance) {\n\t\t\tconst app = new App();\n\t\t\tapp.setIgnoreQueryStringFromRoutePath(true);\n\t\t\tRouter.routerInstance = app;\n\t\t}\n\t\treturn Router.routerInstance;\n\t}\n\n\t/**\n\t * Setter for the \"component\" state property.\n\t * @param {!Function|string} ctor\n\t * @return {!Function}\n\t * @protected\n\t */\n\tsetterComponentFn_(ctor) {\n\t\tif (core.isString(ctor)) {\n\t\t\tctor = ComponentRegistry.getConstructor(ctor);\n\t\t}\n\t\treturn ctor;\n\t}\n\n\t/**\n\t * Makes sure that the `Router` is only rerendered if either `isActive_` or\n\t * `component` has changed. The other state properties are not used for\n\t * rendering.\n\t */\n\tshouldUpdate(changes) {\n\t\treturn changes.isActive_ || changes.component;\n\t}\n\n\t/**\n\t * Converts the given object into an array to be passed to an incremental dom\n\t * call.\n\t * @param {!Object} config\n\t * @return {!Array}\n\t * @protected\n\t */\n\ttoArray_(config) {\n\t\tvar arr = [];\n\t\tvar keys = Object.keys(config || {});\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tarr.push(keys[i], config[keys[i]]);\n\t\t}\n\t\treturn arr;\n\t}\n}\n\nRouter.RENDERER = IncrementalDomRenderer;\n\n/**\n * Router state definition.\n * @type {!Object}\n * @static\n */\nRouter.STATE = {\n\t/**\n\t * Handler to be called before a router is deactivated. Can be given as a\n\t * function reference directly, or as the name of a function to be called in\n\t * the router's component instance.\n\t * @type {!function()|string}\n\t */\n\tbeforeDeactivateHandler: {\n\t\tvalidator: val => core.isString(val) || core.isFunction(val)\n\t},\n\n\t/**\n\t * If set to true navigation will cache component state deferred results.\n\t * @type {boolean}\n\t * @default true\n\t */\n\tcacheable: {\n\t\tvalidator: core.isBoolean,\n\t\tvalue: true\n\t},\n\n\t/**\n\t * The constructor of the component to render when path is accessed.\n\t * @type {!Function|string}\n\t */\n\tcomponent: {\n\t\tsetter: 'setterComponentFn_'\n\t},\n\n\t/**\n\t * Holds the load data value, function or deferred function that\n\t * resolves the component configurations.\n\t * @type {!Object|function(?string=)}\n\t */\n\tdata: {\n\t\tsetter: (val) => core.isFunction(val) ? val : () => (val || {})\n\t},\n\n\t/**\n\t * Flag indicating if the component's data should be loaded via a request\n\t * to the server. By default the data will come from `data` instead.\n\t */\n\tfetch: {\n\t\tvalue: false\n\t},\n\n\t/**\n\t * Url to be used when fetching data for this route. If nothing is given,\n\t * the current path will be used by default. Note that this is only relevant\n\t * if \"fetch\" is set to `true`.\n\t * @type {?string|function()}\n\t */\n\tfetchUrl: {\n\t\tvalidator: val => core.isString(val) || core.isFunction(val)\n\t},\n\n\t/**\n\t * The timeout in ms used by `Router.defaultScreen` in ajax requests for\n\t * fetching data.\n\t * @type {?number}\n\t */\n\tfetchTimeout: {\n\t\tvalidator: val => core.isNumber(val) || !core.isDefAndNotNull(val),\n\t\tvalue: 30000\n\t},\n\n\t/**\n\t * Flag indicating if routing data (such as the current url) should be\n\t * included in the component's data.\n\t */\n\tincludeRoutingData: {\n\t\tvalue: true\n\t},\n\n\t/**\n\t * Internal flag indicating if the router's path is currently active.\n\t * @type {boolean}\n\t */\n\tisActive_: {\n\t\tinternal: true,\n\t\tvalue: false\n\t},\n\n\t/**\n\t * Defines the path which will trigger the route handler responsible for\n\t * rendering the metal component.\n\t * @type {!string|RegExp|Function}\n\t */\n\tpath: {\n\t}\n};\n\n/**\n * Holds the active router.\n * @type {Router}\n * @static\n */\nRouter.activeRouter = null;\n\n/**\n * Holds the active render state.\n * @type {*}\n * @static\n */\nRouter.activeState = null;\n\nclass ComponentScreen extends RequestScreen {\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor(router) {\n\t\tsuper();\n\n\t\tif (!router) {\n\t\t\tthrow new Error('Router not specified for component screen.');\n\t\t}\n\n\t\t/**\n\t\t * Router responsible for the screen.\n\t\t * @type {Router}\n\t\t */\n\t\tthis.router = router;\n\n\t\t// Sets the timeout used by `RequestScreen` to be the one specified by\n\t\t// the router.\n\t\tthis.timeout = router.fetchTimeout;\n\t}\n\n\t/**\n\t * Calls the handler specified by the router's `beforeDeactivateHandler`\n\t * state property.\n\t * @return {?boolean}\n\t */\n\tbeforeDeactivate() {\n\t\tconst handler = this.router.beforeDeactivateHandler;\n\t\tif (handler) {\n\t\t\tif (core.isString(handler)) {\n\t\t\t\tconst comp = this.router.getRouteComponent();\n\t\t\t\tif (comp && core.isFunction(comp[handler])) {\n\t\t\t\t\treturn comp[handler]();\n\t\t\t\t} else {\n\t\t\t\t\tconst compName = getFunctionName(comp);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No function named \"${handler}\" exists inside ${compName}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn handler();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the path that should be used to update navigation history. When\n\t * `fetchUrl` is given we should make sure that the original path is used\n\t * instead of the request one.\n\t * @param {string}\n\t */\n\tbeforeUpdateHistoryPath(path) {\n\t\treturn this.router.fetchUrl ? path : super.beforeUpdateHistoryPath(path);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tevaluateScripts() {}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tevaluateStyles() {}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tflip() {\n\t\tthis.maybeRedirectRouter();\n\n\t\tRouter.activeState = this.router.addRoutingData(\n\t\t\tthis.router.lastPath, this.maybeParseLastLoadedStateAsJson());\n\n\t\tif (Router.activeRouter) {\n\t\t\tRouter.activeRouter.isActive_ = false;\n\t\t\tthis.reuseActiveRouterElementInNewRouter_(this.router);\n\t\t}\n\n\t\tconst deferred = this.waitRouterRenderSubComponents(this.router);\n\t\tRouter.activeRouter = this.router;\n\t\tRouter.activeRouter.isActive_ = true;\n\t\treturn deferred;\n\t}\n\n\t/**\n\t * Gets the url that should be used to fetch data.\n\t * @param {string} path\n\t * @return {string}\n\t * @protected\n\t */\n\tgetFetchUrl_(path) {\n\t\tlet fetchPath = this.router.fetchUrl || path;\n\t\tif (core.isFunction(fetchPath)) {\n\t\t\tfetchPath = fetchPath(path);\n\t\t}\n\t\treturn fetchPath;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tload(path) {\n\t\tthis.setCacheable(this.router.cacheable);\n\t\tvar deferred = CancellablePromise.resolve();\n\t\tlet params;\n\t\tif (this.router.fetch) {\n\t\t\tdeferred = deferred.then(() => super.load(this.getFetchUrl_(path)));\n\t\t} else {\n\t\t\tparams = this.router.extractParams(path);\n\t\t\tdeferred = deferred.then(() => this.router.data(path, params));\n\t\t}\n\t\treturn deferred.then((loadedState) => {\n\t\t\tthis.router.lastPath = path;\n\t\t\tthis.router.lastRedirectPath = this.maybeFindRedirectPath();\n\t\t\tthis.router.lastLoadedState = loadedState;\n\t\t\tthis.router.lastExtractedParams = params;\n\t\t\treturn loadedState;\n\t\t});\n\t}\n\n\t/**\n\t * Some responses made by superclass performs a 302 redirect which will be\n\t * reflected into the browser history path. When redirected, make sure to\n\t * render the best component match to new path.\n\t * @return {?String} Redirect path.\n\t */\n\tmaybeFindRedirectPath() {\n\t\tvar redirectPath = this.beforeUpdateHistoryPath(this.router.lastPath);\n\t\tif (redirectPath !== this.router.lastPath) {\n\t\t\treturn redirectPath;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Some responses made by superclass performs a 302 redirect which will be\n\t * reflected into the browser history path. When redirected, make sure to\n\t * render the best component match to new path. If not found any, it will\n\t * use current router component.\n\t * @return {Router}\n\t */\n\tmaybeFindRedirectRouter() {\n\t\tvar redirectPath = this.maybeFindRedirectPath();\n\t\tif (redirectPath) {\n\t\t\tvar redirectRoute = Router.router().findRoute(redirectPath);\n\t\t\tif (redirectRoute) {\n\t\t\t\t// The initiator component will load the render state and follow any\n\t\t\t\t// \"302\" redirect that may happen. Therefore, the data returned of the\n\t\t\t\t// redirect is used as \"lastLoadedState\" and the \"lastRedirectPath\" as\n\t\t\t\t// \"lastPath\" for redirect router.\n\t\t\t\tredirectRoute.router.lastPath = this.router.lastRedirectPath;\n\t\t\t\tredirectRoute.router.lastLoadedState = this.router.lastLoadedState;\n\t\t\t\treturn redirectRoute.router;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Maybe parses last state as Json, if not able to parse an object is\n\t * returned.\n\t * @return {object}\n\t */\n\tmaybeParseLastLoadedStateAsJson() {\n\t\tvar state = this.router.lastLoadedState;\n\t\ttry {\n\t\t\treturn JSON.parse(state);\n\t\t} catch (err) {\n\t\t\treturn core.isDefAndNotNull(state) ? state : {};\n\t\t}\n\t}\n\n\t/**\n\t * @protected\n\t */\n\tmaybeRedirectRouter() {\n\t\tvar redirectRouter = this.maybeFindRedirectRouter();\n\t\tif (redirectRouter) {\n\t\t\t// If performing a redirect use \"redirectRouter\" as \"this.router\". The\n\t\t\t// initiator \"this.router\" is completely ignored from now on.\n\t\t\tthis.router = redirectRouter;\n\n\t\t\t// Schedule screen cache redirect on \"endNavigate\".\n\t\t\tconst app = Router.router();\n\t\t\tapp.once('endNavigate', () => {\n\t\t\t\tapp.screens[app.redirectPath] = app.screens[app.activePath];\n\t\t\t\tdelete app.screens[app.activePath];\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * If the routers were attached to the same element when created, then they\n\t * should reuse the same element when active, so we can guarantee that they\n\t * will be positioned correctly.\n\t * @param {Router} router The new router.\n\t * @protected\n\t */\n\treuseActiveRouterElementInNewRouter_(router) {\n\t\tconst activeRouter = Router.activeRouter;\n\t\tif (activeRouter !== router) {\n\t\t\tif (activeRouter.firstRenderElement === router.firstRenderElement) {\n\t\t\t\trouter.element = activeRouter.element;\n\t\t\t\tactiveRouter.element = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Router} router\n\t * @return {Promise}\n\t * @protected\n\t */\n\twaitRouterRenderSubComponents(router) {\n\t\treturn new Promise((res) => router.once('rendered', res));\n\t}\n}\n\n/**\n * Default screen used for handling components.\n * @type {ComponentScreen}\n */\nRouter.defaultScreen = ComponentScreen;\n\nexport default Router;\n"],"sourceRoot":"/source/"}