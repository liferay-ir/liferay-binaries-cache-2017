'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (_ref) {
	var t = _ref.types;

	var amdDefineVisitor = {
		/**
   * This is the visitor responsible of namespacing define() calls.
   *
   * The structure of opts inside state is:
   *     namespaces: {
   *     	 module: {
   *     	   name: 'my-package'
   *     	 },
   *     	 dependencies: {
   *     	   name: 'my-package'
   *     	 }
   *     }
   *     imports: [
   *     	 {
   *     	   name: 'project',
   *     	   version: '^1.0.0',
   *     	   modules: [
   *     	     'a-package', 'another-package'
   *     	   ]
   *     	 }
   *     ]
   * @param {Object} path the AST path
   * @param {Object} state the Babel plugin state containing the opts field
   */
		ExpressionStatement: function ExpressionStatement(path, state) {
			var expression = path.node.expression;
			var opts = state.opts;
			var namespaces = opts.namespaces,
			    unrolledImports = opts.unrolledImports;


			if (!t.isCallExpression(expression)) {
				return;
			}

			var callee = expression.callee;


			if (!t.isIdentifier(callee, { name: 'define' })) {
				return;
			}

			var args = expression.arguments;

			var _getDefineIndices = getDefineIndices(t, args),
			    depsIndex = _getDefineIndices.dependencies,
			    nameIndex = _getDefineIndices.name;

			// Namespace module name


			if (namespaces.module && nameIndex !== undefined) {
				var moduleName = args[nameIndex].value;

				args[nameIndex].value = ns.addNamespace(moduleName, namespaces.module);

				state.namesCount++;
			}

			// Namespace dependencies
			if (depsIndex !== undefined) {
				var deps = args[depsIndex].elements;

				deps.forEach(function (dep, i) {
					var moduleName = dep.value;


					if (!t.isStringLiteral(dep) || !mod.isExternalDependency(moduleName) || ns.isNamespaced(moduleName)) {
						return;
					}

					deps[i].value = addDependencyNamespace(moduleName, namespaces.dependencies, unrolledImports);

					state.depsCount++;
				});
			}

			// Don't traverse any more
			path.stop();
		}
	};
	var amdRequireVisitor = {
		/**
   * This is the visitor responsible of namespacing require() calls.
   *
   * The structure of opts inside state is:
   *     namespaces: {
   *     	 module: {
   *     	   name: 'my-package'
   *     	 },
   *     	 dependencies: {
   *     	   name: 'my-package'
   *     	 }
   *     }
   *     imports: [
   *     	 {
   *     	   name: 'project',
   *     	   version: '^1.0.0',
   *     	   modules: [
   *     	     'a-package', 'another-package'
   *     	   ]
   *     	 }
   *     ]
   * @param {Object} path the AST path
   * @param {Object} state the Babel plugin state containing the opts field
   */
		exit: function exit(path, state) {
			var node = path.node;
			var opts = state.opts;
			var namespaces = opts.namespaces,
			    unrolledImports = opts.unrolledImports;


			if (node.name !== 'require') {
				return;
			}

			var parent = path.parent;


			if (!t.isCallExpression(parent)) {
				return;
			}

			var argument = parent.arguments[0];

			if (!t.isLiteral(argument) || !argument.value) {
				return;
			}

			var moduleName = argument.value;


			if (typeof moduleName !== 'string' || mod.isLocalModule(moduleName) || ns.isNamespaced(moduleName)) {
				return;
			}

			// Namespace require argument
			argument.value = addDependencyNamespace(moduleName, namespaces.dependencies, unrolledImports);

			state.requiresCount++;
		}
	};

	return {
		visitor: {
			Program: {
				enter: function enter(path, state) {
					// Prepare configuration
					var ownPkgJson = getOwnPkgJson(state);

					var _babelIpc$get = babelIpc.get(state, function () {
						return {
							rootPkgJson: ownPkgJson,
							globalConfig: {
								imports: state.opts.imports
							}
						};
					}),
					    globalConfig = _babelIpc$get.globalConfig,
					    rootPkgJson = _babelIpc$get.rootPkgJson;

					// Check if we need to namespace module name


					var namespaceModule = rootPkgJson.name !== ownPkgJson.name || rootPkgJson.version !== ownPkgJson.version;

					// Prepare opts for visitors
					state.opts = Object.assign({
						namespaces: {
							module: namespaceModule ? rootPkgJson : undefined,
							dependencies: rootPkgJson
						},
						unrolledImports: (0, _imports.unrollImportsConfig)(globalConfig.imports)
					}, globalConfig, state.opts);

					// Initialize statistics for final report
					state.namesCount = 0;
					state.depsCount = 0;
					state.requiresCount = 0;
				},
				exit: function exit(path, state) {
					// We must traverse the AST again because the
					// transform-es2015-modules-amd plugin emits its define()
					// call after exiting Program node :-(
					path.traverse(amdDefineVisitor, state);

					// Dump final report statistics
					if (state.namesCount > 0 || state.depsCount > 0 || state.requiresCount > 0) {
						var _babelIpc$get2 = babelIpc.get(state, function () {
							return {
								log: new _pluginLogger2.default()
							};
						}),
						    log = _babelIpc$get2.log;

						log.info('namespace-modules', 'Namespaced', state.namesCount, 'define() names,', state.depsCount, 'define() dependencies,', 'and', state.requiresCount, 'require() names');
					}
				}
			},
			Identifier: amdRequireVisitor
		}
	};
};

var _babelIpc = require('liferay-npm-build-tools-common/lib/babel-ipc');

var babelIpc = _interopRequireWildcard(_babelIpc);

var _imports = require('liferay-npm-build-tools-common/lib/imports');

var _modules = require('liferay-npm-build-tools-common/lib/modules');

var mod = _interopRequireWildcard(_modules);

var _namespace = require('liferay-npm-build-tools-common/lib/namespace');

var ns = _interopRequireWildcard(_namespace);

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Add namespace to a module's dependency
 * @param {String} moduleName dependency module name
 * @param {String} namespacePkg package name to use as namespace
 * @param {Object} unrolledImports unrolled imports section of .npmbundlerrc file
 * @return {String} the namespaced module
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function addDependencyNamespace(moduleName, namespacePkg, unrolledImports) {
	var _mod$splitModuleName = mod.splitModuleName(moduleName),
	    pkgName = _mod$splitModuleName.pkgName,
	    scope = _mod$splitModuleName.scope;

	var fullPkgName = mod.joinModuleName(scope, pkgName);
	var pkg = unrolledImports[fullPkgName] || namespacePkg;

	return pkg.name === '' ? moduleName : ns.addNamespace(moduleName, pkg);
}

/**
 * Get our own package.json file
 * @param  {Object} state Babel plugin's state object
 * @return {Object} the contents of our own package.json
 */


/**
 * @return {object} a babel visitor
 */
function getOwnPkgJson(state) {
	var filenameRelative = state.file.opts.filenameRelative;


	return (0, _readJsonSync2.default)((0, _packages.getPackageJsonPath)(filenameRelative));
}

/**
 * Get the indices of define() call arguments
 * @param {Object} t a Babel plugin types object
 * @param {Array} args an array of AST nodes representing the arguments of a define() call
 * @return {Object} an Object with name, dependencies, and factory fields (where missings arguments are undefined)
 */
function getDefineIndices(t, args) {
	var nameIndex = void 0;
	var depsIndex = void 0;
	var factoryIndex = void 0;

	// Define signature is: define(id?, dependencies?, factory);
	switch (args.length) {
		case 1:
			factoryIndex = 0;
			break;

		case 2:
			if (t.isStringLiteral(args[0])) {
				nameIndex = 0;
			} else if (t.isArrayExpression(args[0])) {
				depsIndex = 0;
			}
			factoryIndex = 1;
			break;

		case 3:
			nameIndex = 0;
			depsIndex = 1;
			factoryIndex = 2;
			break;

		default:
			throw new Error('Unexpected argument count of ' + args.length);
	}

	return {
		name: nameIndex,
		dependencies: depsIndex,
		factory: factoryIndex
	};
}
//# sourceMappingURL=index.js.map