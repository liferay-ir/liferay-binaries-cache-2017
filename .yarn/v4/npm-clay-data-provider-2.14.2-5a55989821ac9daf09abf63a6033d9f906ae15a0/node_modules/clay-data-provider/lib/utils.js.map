{"version":3,"sources":["../src/utils.js"],"names":["match","query","string","currentScore","totalScore","queryIndex","result","queryToLowerCase","toLowerCase","stringToLowerCase","index","length","element","value","Infinity","values","score","timeout","ms","promise","Promise","resolve","reject","timeoutId","setTimeout","Error","then","clearTimeout","res","catch","err"],"mappings":";;;;;AAAA;;;;;;;AAOO,IAAMA,wBAAQ,SAARA,KAAQ,CAACC,KAAD,EAAQC,MAAR,EAAmB;AACvC,KAAIC,eAAe,CAAnB;AACA,KAAIC,aAAa,CAAjB;AACA,KAAIC,aAAa,CAAjB;AACA,KAAIC,SAAS,EAAb;;AAEA,KAAIC,mBAAmBN,MAAMO,WAAN,EAAvB;AACA,KAAIC,oBAAoBP,OAAOM,WAAP,EAAxB;;AAEA,MAAK,IAAIE,QAAQ,CAAjB,EAAoBA,QAAQR,OAAOS,MAAnC,EAA2CD,OAA3C,EAAoD;AACnD,MAAIE,UAAUV,OAAOQ,KAAP,CAAd;;AAEA,MAAID,kBAAkBC,KAAlB,MAA6BH,iBAAiBF,UAAjB,CAAjC,EAA+D;AAC9DO,aAAU,EAACC,OAAOD,OAAR,EAAiBZ,OAAO,IAAxB,EAAV;;AAEAK,iBAAc,CAAd;AACAF,mBAAgB,IAAIA,YAApB;AACA,GALD,MAKO;AACNS,aAAU,EAACC,OAAOD,OAAR,EAAV;AACAT,kBAAe,CAAf;AACA;;AAEDC,gBAAcD,YAAd;AACAG,SAAOA,OAAOK,MAAd,IAAwBC,OAAxB;AACA;;AAED,KAAIP,eAAeJ,MAAMU,MAAzB,EAAiC;AAChCP,eAAaF,WAAWD,KAAX,GAAmBa,QAAnB,GAA8BV,UAA3C;AACA,SAAO,EAACW,QAAQT,MAAT,EAAiBU,OAAOZ,UAAxB,EAAP;AACA;;AAED,QAAO,IAAP;AACA,CAhCM;;AAkCP;;;;;;;AAOO,IAAMa,4BAAU,SAAVA,OAAU,CAACC,EAAD,EAAKC,OAAL,EAAiB;AACvC,QAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC,MAAMC,YAAYC,WAAW,YAAM;AAClCF,UAAO,IAAIG,KAAJ,CAAU,SAAV,CAAP;AACA,GAFiB,EAEfP,EAFe,CAAlB;AAGAC,UACEO,IADF,CACO,eAAO;AACZC,gBAAaJ,SAAb;AACAF,WAAQO,GAAR;AACA,GAJF,EAKEC,KALF,CAKQ,eAAO;AACbF,gBAAaJ,SAAb;AACAD,UAAOQ,GAAP;AACA,GARF;AASA,EAbM,CAAP;AAcA,CAfM","file":"utils.js","sourcesContent":["/**\n * If `query` matches to `string`, returns an object with the\n * corresponding characters. If there is no match, return null.\n * @param {!String} query\n * @param {!String} string\n * @return {null|Object}\n */\nexport const match = (query, string) => {\n\tlet currentScore = 0;\n\tlet totalScore = 0;\n\tlet queryIndex = 0;\n\tlet result = [];\n\n\tlet queryToLowerCase = query.toLowerCase();\n\tlet stringToLowerCase = string.toLowerCase();\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tlet element = string[index];\n\n\t\tif (stringToLowerCase[index] === queryToLowerCase[queryIndex]) {\n\t\t\telement = {value: element, match: true};\n\n\t\t\tqueryIndex += 1;\n\t\t\tcurrentScore += 1 + currentScore;\n\t\t} else {\n\t\t\telement = {value: element};\n\t\t\tcurrentScore = 0;\n\t\t}\n\n\t\ttotalScore += currentScore;\n\t\tresult[result.length] = element;\n\t}\n\n\tif (queryIndex === query.length) {\n\t\ttotalScore = string === query ? Infinity : totalScore;\n\t\treturn {values: result, score: totalScore};\n\t}\n\n\treturn null;\n};\n\n/**\n * Implementation of the timeout.\n * Based on: https://github.com/github/fetch/issues/175#issuecomment-125779262\n * @param {!number} ms\n * @param {!Promise} promise\n * @return {Promise}\n */\nexport const timeout = (ms, promise) => {\n\treturn new Promise((resolve, reject) => {\n\t\tconst timeoutId = setTimeout(() => {\n\t\t\treject(new Error('timeout'));\n\t\t}, ms);\n\t\tpromise\n\t\t\t.then(res => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\tresolve(res);\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\treject(err);\n\t\t\t});\n\t});\n};\n"]}