'use strict';

var _fsExtra = require('fs-extra');

var fs = _interopRequireWildcard(_fsExtra);

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

var _recursiveCopy = require('recursive-copy');

var _recursiveCopy2 = _interopRequireDefault(_recursiveCopy);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Package descriptor used in tests
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

var pkg = {
	id: 'package@1.0.0',
	name: 'package',
	version: '1.0.0',
	dir: __dirname + '/pkg'
};

var log = void 0;

// Restore package status prior to running each test
beforeEach(function (done) {
	log = new _pluginLogger2.default();

	(0, _recursiveCopy2.default)(__dirname + '/__fixtures__', pkg.dir, { overwrite: true }).then(done);
});

// Delete result files after running each test
afterEach(function () {
	fs.emptyDirSync(pkg.dir);
	fs.rmdirSync(pkg.dir);
});

it('logs results correctly', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		main: 'test-main.js',
		browser: 'test-browser.js'
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(log.messages).toMatchSnapshot();
});

it('replaces main file with browser file', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		main: 'test-main.js',
		browser: 'test-browser.js'
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(fs.readFileSync(pkg.dir + '/test-main.js').toString()).toMatchSnapshot();
});

it('replaces main directory with browser file', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		main: './dir',
		browser: 'test-browser.js'
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(fs.readFileSync(pkg.dir + '/dir/index.js').toString()).toMatchSnapshot();
});

it('works with unpkg field too', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		main: 'test-main.js',
		unpkg: 'test-browser.js'
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(fs.readFileSync(pkg.dir + '/test-main.js').toString()).toMatchSnapshot();
});

it('works with jsdelivr field too', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		main: 'test-main.js',
		jsdelivr: 'test-browser.js'
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(fs.readFileSync(pkg.dir + '/test-main.js').toString()).toMatchSnapshot();
});

it('replaces server files with browser files', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		browser: {
			dir: 'test-main.js',
			'test-browser.js': 'test.js',
			'test-browser-2.js': 'test-2.js'
		}
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(fs.readFileSync(pkg.dir + '/dir/index.js').toString()).toMatchSnapshot();
	expect(fs.readFileSync(pkg.dir + '/test-browser.js').toString()).toMatchSnapshot();
	expect(fs.readFileSync(pkg.dir + '/test-browser-2.js').toString()).toMatchSnapshot();
});

it('does replace ignored modules with empty objects', function () {
	var pkgJson = {
		name: pkg.name,
		version: pkg.version,
		main: 'main.js',
		browser: {
			'test-browser.js': false
		}
	};

	(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

	expect(fs.readFileSync(pkg.dir + '/test-browser.js').toString()).toMatchSnapshot();
});

describe('works well with non-existent files', function () {
	it('when browser field has a unique file', function () {
		var pkgJson = {
			name: pkg.name,
			version: pkg.version,
			main: 'main.js',
			browser: 'non-existent-file.js'
		};

		(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

		expect(fs.readFileSync(pkg.dir + '/main.js').toString()).toMatchSnapshot();
	});

	it('when browser field has several files', function () {
		var pkgJson = {
			name: pkg.name,
			version: pkg.version,
			main: 'main.js',
			browser: {
				'non-existent-file.js': false,
				'non-existent-dir/non-existent-file-in-dir.js': false,
				'non-existent-file-2.js': 'test-browser.js',
				'non-existent-file-3.js': 'non-existent-file-4.js'
			}
		};

		(0, _index2.default)({ pkg: pkg, log: log }, { pkgJson: pkgJson });

		expect(fs.readFileSync(pkg.dir + '/non-existent-file.js').toString()).toMatchSnapshot();
		expect(fs.readFileSync(pkg.dir + '/non-existent-dir/non-existent-file-in-dir.js').toString()).toMatchSnapshot();
		expect(fs.readFileSync(pkg.dir + '/non-existent-file-2.js').toString()).toMatchSnapshot();
		expect(fs.readFileSync(pkg.dir + '/non-existent-file-3.js').toString()).toMatchSnapshot();
	});
});
//# sourceMappingURL=index.test.js.map