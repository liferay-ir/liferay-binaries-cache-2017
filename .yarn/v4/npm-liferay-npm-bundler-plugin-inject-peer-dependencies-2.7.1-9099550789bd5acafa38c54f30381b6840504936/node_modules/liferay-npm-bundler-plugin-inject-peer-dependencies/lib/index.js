'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (_ref, _ref2) {
	var config = _ref.config,
	    log = _ref.log,
	    pkg = _ref.pkg,
	    rootPkgJson = _ref.rootPkgJson,
	    source = _ref.source;
	var pkgJson = _ref2.pkgJson;

	var defineCall = (config.defineCall || 'Liferay.Loader.define') + '(';

	pkgJson.dependencies = pkgJson.dependencies || {};

	var injectedDeps = {};
	var failedDeps = {};

	globby.sync([path.join(path.resolve(pkg.dir), '**/*.js')]).forEach(function (filePath) {
		var code = fs.readFileSync(filePath);
		var defineCallOffset = code.indexOf(defineCall);

		if (defineCallOffset != -1) {
			var funOffset = code.indexOf(')', defineCallOffset);
			var defineCallLine = void 0;

			if (code instanceof Buffer) {
				defineCallLine = code.toString('utf8', defineCallOffset + defineCall.length, funOffset);
			} else {
				defineCallLine = code.substring(defineCallOffset + defineCall.length, funOffset);
			}
			defineCallLine = defineCallLine.replace(/\n/g, ' ');

			defineCallLine = removeModuleName(defineCallLine);

			defineCallLine = defineCallLine.trim();

			var deps = extractDependencies(defineCallLine);

			processModuleDependencies(rootPkgJson, pkgJson, filePath, deps, source.pkg.dir, injectedDeps, failedDeps);
		}
	});

	Object.keys(injectedDeps).forEach(function (dep) {
		log.info('inject-peer-dependencies', 'Injected dependency', dep + '@' + injectedDeps[dep]);
	});

	Object.keys(failedDeps).forEach(function (dep) {
		log.warn('inject-peer-dependencies', 'Failed to resolve dependency', dep, 'with error:', failedDeps[dep]);
	});
};

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _globby = require('globby');

var globby = _interopRequireWildcard(_globby);

var _modules = require('liferay-npm-build-tools-common/lib/modules');

var mod = _interopRequireWildcard(_modules);

var _namespace = require('liferay-npm-build-tools-common/lib/namespace');

var ns = _interopRequireWildcard(_namespace);

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Process dependencies of a file.
 * @param {Object} rootPkgJson root project's package.json
 * @param {Object} pkgJson processed module's package.json
 * @param {String} filePath path to module file
 * @param {Array} deps array of dependencies as passed to define() call
 * @param {String} resolveDir path from where to resolve dependencies
 * @param {Object} injectedDeps a hash to fill with resolved dependencies
 * @param {Object} failedDeps a hash to fill with failed dependencies
 * @return {void}
 */
/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

function processModuleDependencies(rootPkgJson, pkgJson, filePath, deps, resolveDir, injectedDeps, failedDeps) {
	deps.forEach(function (dep) {
		if (!mod.isExternalDependency(dep) || mod.isNodeCoreModule(dep)) {
			return;
		}

		var _mod$splitModuleName = mod.splitModuleName(dep),
		    pkgName = _mod$splitModuleName.pkgName,
		    scope = _mod$splitModuleName.scope;

		var scopedPkgName = mod.joinModuleName(scope, pkgName);

		if (!pkgJson.dependencies[scopedPkgName]) {
			var srcPkgName = ns.removeNamespace(scopedPkgName);

			try {
				var resolvedPkgJsonPath = _resolve2.default.sync(srcPkgName + '/package.json', {
					basedir: resolveDir
				});

				var resolvedPkgJson = (0, _readJsonSync2.default)(resolvedPkgJsonPath);

				pkgJson.dependencies[scopedPkgName] = resolvedPkgJson.version;

				injectedDeps[scopedPkgName] = resolvedPkgJson.version;
			} catch (err) {
				failedDeps[dep] = err;
			}
		}
	});
}

/**
 * Removes module name argument from a define call
 * @param  {String} line the line containing a define call
 * @return {String} the rest of the line without module name
 */


/**
 * @return {void}
 */
function removeModuleName(line) {
	var inString = false;

	for (var i = 0; i < line.length; i++) {
		if (inString) {
			if (line[i] === inString) {
				inString = false;
			}
		} else {
			switch (line[i]) {
				case "'":
				case '"':
					inString = line[i];
					break;

				case ',':
					return line.substr(i + 1);

				default:
				// Keep scanning.
			}
		}
	}

	return '';
}

/**
 * Extracts dependencies argument from a define call
 * @param  {String} line the line containing a define call starting at the
 * 							dependencies argument
 * @return {Array} an array with
 */
function extractDependencies(line) {
	var indexOfClose = line.indexOf(']');

	if (!line.startsWith('[') || indexOfClose == -1) {
		return [];
	}

	return line.substring(1, indexOfClose).split(',').map(function (dep) {
		return dep.trim();
	}).map(function (dep) {
		return dep.replace(/['"]/g, '');
	});
}
//# sourceMappingURL=index.js.map