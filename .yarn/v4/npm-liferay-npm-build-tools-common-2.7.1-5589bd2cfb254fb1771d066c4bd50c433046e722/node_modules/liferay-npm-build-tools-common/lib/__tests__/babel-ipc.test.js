'use strict';

var _babelIpc = require('../babel-ipc');

var babelIpc = _interopRequireWildcard(_babelIpc);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var filePath = __filename; /**
                            * Â© 2017 Liferay, Inc. <https://liferay.com>
                            *
                            * SPDX-License-Identifier: LGPL-3.0-or-later
                            */

var state = {
	file: {
		opts: {
			filenameRelative: filePath
		}
	}
};

beforeEach(function () {
	babelIpc.clear(filePath);
	expect(babelIpc.get(state)).toBeUndefined();
});

it('set/get works', function () {
	var value = 'value-for-set/get-test';

	babelIpc.set(filePath, value);

	expect(babelIpc.get(state)).toBe(value);
});

it('get with default value works', function () {
	var value = 'value-for-default-test';

	expect(babelIpc.get(state, value)).toBe(value);
});

it('get with default value factory works', function () {
	var value = 'value-for-factory-test';
	var factory = function factory() {
		return 'value-for-factory-test';
	};

	expect(babelIpc.get(state, factory)).toBe(value);
});

it('clear works', function () {
	var value = 'value-for-clear-test';

	babelIpc.set(filePath, value);

	expect(babelIpc.get(state)).toBe(value);

	babelIpc.clear(filePath);

	expect(babelIpc.get(state)).toBeUndefined();
});
//# sourceMappingURL=babel-ipc.test.js.map