'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Â© 2017 Liferay, Inc. <https://liferay.com>
 *
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */

/**
 * A package descriptor class to identify directories containing packages.
 * @type {PkgDesc}
 */
var PkgDesc = function () {
	/**
  * Constructor
  * @param {String} name name of package
  * @param {String} version version number
  * @param {String} dir directory where package lives (or null if it is the root package)
  * @param {Boolean} forceRoot create a root package even if dir is not null
  */
	function PkgDesc(name, version, dir) {
		var forceRoot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

		_classCallCheck(this, PkgDesc);

		this._name = name;
		this._version = version;

		if (!dir || forceRoot) {
			this.dir = dir ? dir : '.';
			this._id = PkgDesc.ROOT_ID;
		} else {
			this.dir = dir;
			this._id = name + '@' + version;
		}
	}

	/**
  * Clone this object and optionally modify some of its fields.
  * @return {PkgDesc} a clone of this (perhaps modified) package descriptor
  */


	_createClass(PkgDesc, [{
		key: 'clone',
		value: function clone() {
			var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			    dir = _ref.dir;

			var clone = new PkgDesc(this.name, this.version, this.dir, this.isRoot);

			if (dir) {
				clone.dir = dir;
			}

			return clone;
		}

		/** eslint require-js-doc off */

	}, {
		key: 'id',
		get: function get() {
			return this._id;
		}

		// eslint-disable-next-line require-jsdoc
		,
		set: function set(id) {
			throw new Error('Package ids are read-only');
		}

		// eslint-disable-next-line require-jsdoc

	}, {
		key: 'name',
		get: function get() {
			return this._name;
		}

		// eslint-disable-next-line require-jsdoc
		,
		set: function set(name) {
			throw new Error('Package names are read-only');
		}

		// eslint-disable-next-line require-jsdoc

	}, {
		key: 'version',
		get: function get() {
			return this._version;
		}

		// eslint-disable-next-line require-jsdoc
		,
		set: function set(version) {
			throw new Error('Package versions are read-only');
		}

		/**
   * Test if package is the root package.
   * @return {Boolean} true if this is the root package
   */

	}, {
		key: 'isRoot',
		get: function get() {
			return this.id == PkgDesc.ROOT_ID;
		}
	}]);

	return PkgDesc;
}();

exports.default = PkgDesc;


PkgDesc.ROOT_ID = '/';
//# sourceMappingURL=pkg-desc.js.map